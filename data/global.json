{
  "file": "global.html",
  "props": [
    {
      "section": "Members",
      "name": "__cachedLines",
      "hash": "#__cachedLines",
      "desc": "Cached array of text wrapping."
    },
    {
      "section": "Members",
      "name": "dynamicMinWidth",
      "hash": "#dynamicMinWidth",
      "desc": "Minimum calculated width of a textbox, in pixels. fixed to 2 so that an empty textbox cannot go to 0 and is still selectable without text."
    },
    {
      "section": "Members",
      "name": "lockScalingFlip",
      "hash": "#lockScalingFlip",
      "desc": "Override standard Object class values"
    },
    {
      "section": "Members",
      "name": "minWidth",
      "hash": "#minWidth",
      "desc": "Minimum width of textbox, in pixels."
    },
    {
      "section": "Members",
      "name": "noScaleCache",
      "hash": "#noScaleCache",
      "desc": "Override standard Object class values Textbox needs this on false"
    },
    {
      "section": "Members",
      "name": "splitByGrapheme",
      "hash": "#splitByGrapheme",
      "desc": "Use this boolean property in order to split strings that have no white space concept. this is a cheap way to help with chinese/japanese"
    },
    {
      "section": "Members",
      "name": "type",
      "hash": "#type",
      "desc": "Type of an object"
    },
    {
      "section": "Methods",
      "name": "_splitTextIntoLines",
      "hash": "#_splitTextIntoLines",
      "desc": "Gets lines of text to render in the Textbox. This function calculates text wrapping on the fly every time it is called."
    },
    {
      "section": "Methods",
      "name": "_wrapLine",
      "hash": "#_wrapLine",
      "desc": "Wraps a line of text using the width of the Textbox and a context."
    },
    {
      "section": "Methods",
      "name": "_wrapText",
      "hash": "#_wrapText",
      "desc": "Wraps text using the 'width' property of Textbox. First this function splits text on newlines, so we preserve newlines entered by the user. Then it wraps each line using the width of the Textbox by calling _wrapLine()."
    },
    {
      "section": "Methods",
      "name": "applyFilters",
      "hash": "#applyFilters",
      "desc": "Applies filters assigned to this image (from \"filters\" array) or from filter param"
    },
    {
      "section": "Methods",
      "name": "cancelAll",
      "hash": "#cancelAll",
      "desc": "cancel all running animations at the next requestAnimFrame"
    },
    {
      "section": "Methods",
      "name": "cancelByCanvas",
      "hash": "#cancelByCanvas",
      "desc": "cancel all running animations attached to canvas at the next requestAnimFrame"
    },
    {
      "section": "Methods",
      "name": "cancelByTarget",
      "hash": "#cancelByTarget",
      "desc": "cancel all running animations for target at the next requestAnimFrame"
    },
    {
      "section": "Methods",
      "name": "copyGLTo2DDrawImage",
      "hash": "#copyGLTo2DDrawImage",
      "desc": "Copy an input WebGL canvas on to an output 2D canvas.  The WebGL canvas is assumed to be upside down, with the top-left pixel of the desired output image appearing in the bottom-left corner of the WebGL canvas."
    },
    {
      "section": "Methods",
      "name": "copyGLTo2DPutImageData",
      "hash": "#copyGLTo2DPutImageData",
      "desc": "Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra)."
    },
    {
      "section": "Methods",
      "name": "findAnimation",
      "hash": "#findAnimation",
      "desc": null
    },
    {
      "section": "Methods",
      "name": "findAnimationIndex",
      "hash": "#findAnimationIndex",
      "desc": null
    },
    {
      "section": "Methods",
      "name": "findAnimationsByTarget",
      "hash": "#findAnimationsByTarget",
      "desc": null
    },
    {
      "section": "Methods",
      "name": "isEmptyStyles",
      "hash": "#isEmptyStyles",
      "desc": "Returns true if object has no styling or no styling in a line"
    },
    {
      "section": "Methods",
      "name": "isEndOfWrapping",
      "hash": "#isEndOfWrapping",
      "desc": "Detect if the text line is ended with an hard break text and itext do not have wrapping, return false"
    },
    {
      "section": "Methods",
      "name": "missingNewlineOffset",
      "hash": "#missingNewlineOffset",
      "desc": "Detect if a line has a linebreak and so we need to account for it when moving and counting style."
    },
    {
      "section": "Methods",
      "name": "styleHas",
      "hash": "#styleHas",
      "desc": "Returns true if object has a style property or has it on a specified line"
    },
    {
      "section": "Methods",
      "name": "toObject",
      "hash": "#toObject",
      "desc": "Returns object representation of an instance"
    },
    {
      "section": "Methods",
      "name": "toObject",
      "hash": "#toObject",
      "desc": "Returns object representation of an instance"
    }
  ]
}